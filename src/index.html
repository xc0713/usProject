<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
     //let和const
     //属性描述符: writable,configurable,enurmable,value,get,set
     var obj={a:1};
     //测试writable,是否可写(可覆盖)   默认是false 
     Object.defineProperty(obj,'a',{
         writable:true
     }) 
    //测试configurable,是否可被删除 // delete    默认是false 
    Object.defineProperty(obj,'a',{
        configurable:true
    })
    
    //测试enurmable,是否可被枚举(遍历)   默认是false 
    Object.defineProperty(obj,'a',{
        enumerable:true
    })
    //测试value 该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。
    Object.defineProperty(obj,'a',{
        value:true
    })
    //测试get/ 该方法返回值被用作属性值      set该方法将接受唯一参数，并将该参数的新值分配给该属性
    Object.defineProperty(obj,'a',{
      get(){
          return value
      },
      set(val){
         value=val
      }
    })

    //proxy 可以修改某些操作的默认行为的[代理器]
    // var obj2={}
    // var proxy=new Proxy(obj2,{
    //    get(target,key){
    //     console.log('target....',target,key)
    //    },
    //    set(target,key,val){
    //      console.log('target...',target,key,val)
    //    }
    // })


class Watch { // 生成一个watch类
    constructor() {
        this.emit = dispatchEvent.bind(document); 
        this.on = addEventListener.bind(document);
        this.eventUpdated = new Event('updated');
        this.eventRead = new Event('read');
        this.eventChanged = new Event('changed'); 
    } //对事件的方法进行初始化。
 
    createProxy(obj3) { //用此函数来生成一个proxy对象
        let _this = this;
        return new Proxy(obj3, {
            get(target, prop) {
                _this.emit(_this.eventRead); //在get属性时触发read事件
                return target[prop];
            },
            set(target, prop, val) {
                let oldVal = target[prop]; 
                target[prop] = val;
                if(oldVal != val) _this.emit(_this.eventChanged); //在set属性时，如果新值和旧值不一样，触发changed事件
                 _this.emit(_this.eventUpdated); //在set属性时，触发updated事件
            }
        });
    }
 
    on(eventStr, callback) { //监听事件并且回调
        this.on(eventStr, function () {
            callback();
        });
    }
}

let obj3 = {
    name: 'ss',
    age: 10,
} //声明一个对象
 
 
let watchable = new Watch(); //生成一个watch实例
let proxy = watchable.createProxy(obj3); //对obj生成一个proxy对象
console.log(watchable,'watchable')
console.log(proxy,'proxy')
watchable.on('updated', () => {
    console.log('updated')
    console.log(obj3)
}); //当proxy的属性被读取的时候触发回调
 
watchable.on('read', () => {
    console.log('read');
    console.log(obj3)
})//当proxy属性被设置的时候触发回调
 
watchable.on('changed', () => {
    console.log('changed')
    console.log(obj3)
})//当proxy属性被重新设置并且值不一样的时候触发回调
 
proxy.name = 'sss' //changed {name: "sss", age: 10} updated {name: "sss", age: 10}

//**************
//Promise的三种状态:padding(初始状态)，fulfilled(异步成功之后的状态)，rejected(异步失败的状态)
//一种即异步的结果：如果成功状态由padding——>fulfilled；否则状态由padding——>rejected。无法提供其他方式改变状态。
//状态一旦改变就无法更改。
//无法取消Promise，一旦建立就会执行。。。
//调用的时候再执行promise对象
  function loadImg(src){
            function MyPromise(){
                this.status='pending';
                this.msg='';
                var process=arguments[0];
                var that=this;
                process(function(){
                    that.status='resolve';
                    that.msg=arguments[0];
                },function(){
                    that.status='reject';     
                    that.msg=arguments[0];           
                });
                console.log(this)
                return this;
            }
        MyPromise.prototype.then=function(){
            if(this.status=='resolve'){
                arguments[0](this.msg);
            }
            if(this.status=='reject'&&arguments[1]){
                arguments[1](this.msg);
            }
        }
      return new MyPromise((resolve,reject)=>{
          let img=new Image();
          img.src=src;
          img.onload=function(){
              resolve(img)
          }
          img.onerror=function(e){
              reject(e)
          }
      })
  }
  let url='https://avatar-static.segmentfault.com/194/808/1948081578-565bcd718b827_big64'
  loadImg(url).then(res=>{
    document.body.appendChild(res)
  },err=>{

  })

  
//   let url='https://avatar-static.segmentfault.com/194/808/1948081578-565bcd718b827_big64'
//   loadImg(url).then(res=>{    //第一个参数代表resolve成功,第二个代表失败reject
//        document.body.appendChild(res)
//       console.log(res,"res")
//   },err=>{
//       console.log(err,'err')
//   }).catch(res=>{      //用于指定发生错误时的回调函数
//       console.log(res,'catch')
//   }).finally(res=>{   //成功失败都会走
//        console.log(res,'finally')
//   })



// var mm=new MyPromise(function(resolve,reject){
//        if((1+1)==2){
//           resolve("123")
//        }else{
//           reject("报错了")
//        }
// });


// mm.then(function(success){
//     console.log(success);
//     console.log("ok!");
// },function(){
//     console.log('fail!');
// })

     
    </script>
</body>
</html>