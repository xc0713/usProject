<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
     //let和const
     //属性描述符: writable,configurable,enurmable,value,get,set
     var obj={a:1};
     //测试writable,是否可写(可覆盖)   默认是false 
     Object.defineProperty(obj,'a',{
         writable:true
     })
    //测试configurable,是否可被删除 // delete    默认是false 
    Object.defineProperty(obj,'a',{
        configurable:true
    })
    
    //测试enurmable,是否可被枚举(遍历)   默认是false 
    Object.defineProperty(obj,'a',{
        enumerable:true
    })
    //测试value 该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。
    Object.defineProperty(obj,'a',{
        value:true
    })
    //测试get/ 该方法返回值被用作属性值      set该方法将接受唯一参数，并将该参数的新值分配给该属性
    Object.defineProperty(obj,'a',{
      get(){
          return value
      },
      set(val){
         value=val
      }
    })

    //proxy 可以修改某些操作的默认行为的[代理器]
    // var obj2={}
    // var proxy=new Proxy(obj2,{
    //    get(target,key){
    //     console.log('target....',target,key)
    //    },
    //    set(target,key,val){
    //      console.log('target...',target,key,val)
    //    }
    // })


class Watch { // 生成一个watch类
    constructor() {
        this.emit = dispatchEvent.bind(document); 
        this.on = addEventListener.bind(document);
        this.eventUpdated = new Event('updated');
        this.eventRead = new Event('read');
        this.eventChanged = new Event('changed'); 
    } //对事件的方法进行初始化。
 
    createProxy(obj3) { //用此函数来生成一个proxy对象
        let _this = this;
        return new Proxy(obj3, {
            get(target, prop) {
                _this.emit(_this.eventRead); //在get属性时触发read事件
                return target[prop];
            },
            set(target, prop, val) {
                let oldVal = target[prop]; 
                target[prop] = val;
                if(oldVal != val) _this.emit(_this.eventChanged); //在set属性时，如果新值和旧值不一样，触发changed事件
                 _this.emit(_this.eventUpdated); //在set属性时，触发updated事件
            }
        });
    }
 
    on(eventStr, callback) { //监听事件并且回调
        this.on(eventStr, function () {
            callback();
        });
    }
}

let obj3 = {
    name: 'ss',
    age: 10,
} //声明一个对象
 
 
let watchable = new Watch(); //生成一个watch实例
let proxy = watchable.createProxy(obj3); //对obj生成一个proxy对象
console.log(watchable,'watchable')
console.log(proxy,'proxy')
watchable.on('updated', () => {
    console.log('updated')
    console.log(obj3)
}); //当proxy的属性被读取的时候触发回调
 
watchable.on('read', () => {
    console.log('read');
    console.log(obj3)
})//当proxy属性被设置的时候触发回调
 
watchable.on('changed', () => {
    console.log('changed')
    console.log(obj3)
})//当proxy属性被重新设置并且值不一样的时候触发回调
 
proxy.name = 'sss' //changed {name: "sss", age: 10} updated {name: "sss", age: 10}

//**************
//Promise的三种状态:pending就是未决，resolve可以理解为成功，reject可以理解为拒绝。
  function loadImg(src){
      return new Promise((resolve,reject)=>{
          let img=new Image();
          img.src=src;
          img.onload=function(){
              resolve(img)
          }
          img.onerror=function(e){
              reject(e)
          }
      })
  }
  let url='https://avatar-static.segmentfault.com/194/808/1948081578-565bcd718b827_big64'
  loadImg(url).then(res=>{
       document.body.appendChild(res)
      console.log(res,"res")
  },err=>{
      console.log(err,'err')
  }).catch(res=>{      //用于指定发生错误时的回调函数
      console.log(res,'catch')
  }).finally(res=>{   //成功失败都会走
       console.log(res,'finally')
  })
     
    </script>
</body>
</html>